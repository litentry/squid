import {
  EventHandlerContext,
  CallHandlerContext,
} from '@subsquid/substrate-processor';
import { decodeAddress } from '../utils';
import { SubstrateBountyProposal, SubstrateNetwork } from '../model';
import { getOrCreateGovernanceAccount } from '../utils';
import { getBountiesBountyProposedEvent } from './typeGetters/getBountiesBountyProposedEvent';
import { getBountiesProposedCall } from './typeGetters/getBountiesProposedCall';
import { Store } from '@subsquid/typeorm-store';
import getCallOriginAccount from '../utils/getCallOriginAccount';
import assert from 'assert';

export default (network: SubstrateNetwork) =>
  async (ctx: EventHandlerContext<Store>) => {
    if (!ctx.event.extrinsic) {
      return;
    }
    const blockNumber = BigInt(ctx.block.height);
    const date = new Date(ctx.block.timestamp);
    const address = getCallOriginAccount(ctx.event.call.origin, network);
    assert(address);
    const event = getBountiesBountyProposedEvent(ctx, network);

    const account = await getOrCreateGovernanceAccount(ctx.store, {
      id: address,
      publicKey: address,
      network,
    });
    account.totalBountyProposals++;
    await ctx.store.save(account);

    let value;
    let description;

    // bounty info
    try {
      const call = getBountiesProposedCall(
        ctx,
        network
      );
      description = Buffer.from(call.description).toString();
      value = call.value;
    } catch (e) {
      console.warn(
        `bounties.bountyProposed event: extrinsic hidden in wrapped call - ${ctx.extrinsic?.name}, not setting beneficiary or value fields`
      );
    }

    const proposal = new SubstrateBountyProposal({
      id: `${network}:${blockNumber.toString()}:${ctx.event.indexInBlock}`,
      network,
      account,
      publicKey,
      blockNumber,
      date,
      proposalIndex: event.index,
      description,
      value,
    });

    await ctx.store.save(proposal);
  };
